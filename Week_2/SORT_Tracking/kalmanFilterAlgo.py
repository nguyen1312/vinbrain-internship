from lib import *
from converter import *

class KalmanBBoxTracker(object):
    count = 0
    def __init__(self, bbox):
        # dim_x = 7, number of state variables for the Kalman filter
        dim_x = 7 
        # dim_z = 4, number of of measurement inputs
        dim_z = 4
        # use module KalmanFilter from filterpy
        self.kf = KalmanFilter(dim_x = dim_x, dim_z = dim_z)
        # init state (x_center, y_center, scale, ratio, x', y', s') (dim_x, 1)
        self.kf.x[:4] = convert_bbox_to_z(bbox)
        # KF.F: state transition matrix (dim_x, dim_x)
        self.kf.F = np.array([[1, 0, 0, 0, 1, 0, 0],
                              [0, 1, 0, 0, 0, 1, 0],
                              [0, 0, 1, 0, 0, 0, 1],
                              [0, 0, 0, 1, 0, 0, 0],
                              [0, 0, 0, 0, 1, 0, 0],
                              [0, 0, 0, 0, 0, 1, 0],
                              [0, 0, 0, 0, 0, 0, 1]])
        # KF.H: measurement function (dim_z, dim_x)
        self.kf.H = np.array([[1, 0, 0, 0, 0, 0, 0],
                              [0, 1, 0, 0, 0, 0, 0],
                              [0, 0, 1, 0, 0, 0, 0],
                              [0, 0, 0, 1, 0, 0, 0]])
        # KF.P: covariance matrix (dim_x, dim_x)
        # set unobservable initial velocities with high uncertainty
        self.kf.P[4:, 4:] *= 1000.  
        self.kf.P *= 10.
        # KF.R: measurement noise covariance (dim_z, dim_z)
        self.kf.R[2:, 2:] *= 10.
        # KF.Q: process uncertainty  (dim_x, dim_x)
        self.kf.Q[-1, -1] *= 0.01
        self.kf.Q[4:, 4:] *= 0.01
        # when applying an input (dectection, aka bbox) -> set id 
        self.id = KalmanBBoxTracker.count
        # update count to set new id to new input
        KalmanBBoxTracker.count += 1
        
        # if track is updated -> time_since_update reset to 0 -> ensure lower than max_age
        self.time_since_update = 0
        # save version track
        self.history = []

        # should we keep or remove track ?
        self.hits = 0
        self.hit_streak = 0
        
        # record the tracker preserved time
        self.age = 0   
        # final element in each bbox generated by YoLoV5 is class index
        self.objclass = bbox[-1]        
    
    # Update the state vector with observed bbox
    def update(self, bbox):
        self.time_since_update = 0
        self.history = []
        self.hits += 1
        self.hit_streak += 1
        self.kf.update(convert_bbox_to_z(bbox))
    
    # Advances the state vector and returns the predicted bounding box estimate
    def predict(self):
        # area and the area velocity
        if self.kf.x[6] + self.kf.x[2] <= 0:
            self.kf.x[6] *= 0.0
        
        self.kf.predict()
        self.age += 1

        if self.time_since_update > 0:
            self.hit_streak = 0

        self.time_since_update += 1

        self.history.append(convert_x_to_bbox(self.kf.x))
        return self.history[-1]
    
    # Returns the current bounding box estimate
    def get_state(self):
        return convert_x_to_bbox(self.kf.x)